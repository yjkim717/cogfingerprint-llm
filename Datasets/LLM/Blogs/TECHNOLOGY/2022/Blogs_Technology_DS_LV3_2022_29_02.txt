It’s funny how the ghosts of old languages linger in our minds, long after we’ve moved on to newer, shinier tools. I was designing a module system for a small experimental language in late 2022, and I found myself instinctively reaching for a familiar pattern: implicit imports from the standard library. You type `print`, and it just *works*. No ceremony. It’s a convenience I’d inherited, a habit carved deep from my early days wrestling with C and C++.

But then I paused. Why was I defaulting to this? Was it truly the best path, or was I just recreating the comfort of my programming youth?

This line of thinking led me down a rabbit hole. Implicit imports feel like a warm blanket. They make code look cleaner, less cluttered with boilerplate `import` statements. It’s the programming equivalent of a well-stocked kitchen—everything you need is just *there*. For a beginner, it’s a gentler on-ramp. There’s a certain magic in writing a few lines and having a program run, unburdened by the scaffolding of explicit dependencies.

Yet, that very magic can become a source of fog. I remember a nasty bug a few years back, a classic case of a namespace collision. My function, innocently named `list`, was suddenly at war with the implicitly imported standard library type. The compiler error was cryptic, sending me on a wild goose chase. The time I saved by not typing an import statement was utterly lost in debugging. That’s the trade-off. For the sake of a little convenience at the start, we risk ambiguity and confusion later. The compile-time cost of resolving these invisible dependencies isn't zero, either.

It made me wonder if our attachment to this model is more about nostalgia than objective superiority. We’re so used to the quirks of our first languages that we enshrine them as virtues. What if, for the sake of long-term clarity and collaboration, we embraced a different default? What if a language required you to explicitly invite a function into your namespace, making the contract between your code and the standard library unmistakably clear from line one?

It’s not about right or wrong, but about intention. Are we designing for the initial "wow" or for the thousandth day of maintenance? The habits of C and C++ got us far, but as we build the next generation of languages, perhaps the most inclusive default is one that prizes explicit clarity over implicit assumption. After all, the clearest path is often the one you’ve deliberately chosen to walk, not the one you simply stumbled onto out of habit.
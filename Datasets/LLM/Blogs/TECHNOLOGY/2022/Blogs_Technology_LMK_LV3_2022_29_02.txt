The Unseen Influence of Programming Languages: A Reflection on Implicit Imports

As I sat down to design a new programming language in 2022, I couldn't help but think about the diverse backgrounds of our potential users. With so many programming languages out there, it's natural that our team members brought their own experiences to the table. But, as we began discussing the language's design, particularly around implicit imports, I realized just how much our prior experiences were influencing our decisions.

For those who might not be familiar, implicit imports refer to the automatic inclusion of certain modules or libraries in a programming language, making it easier for developers to get started without having to manually import everything they need. It's a feature that's become second nature in some languages, like Python, where the standard library is vast and easily accessible. However, this wasn't always the case, and our team's varied backgrounds led to differing opinions on how to handle implicit imports in our new language.

Some team members, coming from a JavaScript background, advocated for a minimalistic approach, where only the most essential modules were implicitly imported. Others, with experience in languages like Rust, pushed for a more explicit approach, where developers had to manually import every module they used. Meanwhile, those familiar with languages like Haskell argued that a more comprehensive standard library would be beneficial, with many useful functions available out of the box.

As we debated, it became clear that our individual experiences were shaping our perspectives. We were, in essence, trying to recreate the languages we loved, or fix the ones we didn't, in our new design. This made me reflect on how much our prior experiences influence our design decisions. When creating something new, it's easy to get caught up in what we know and love, rather than considering what might be best for the new language and its users.

In the end, we found a balance that worked for our language. We opted for a moderate approach, with a reasonably sized standard library and a clear mechanism for importing additional modules. It was a decision that was both informed by our collective experience and mindful of the potential pitfalls of implicit imports. As I look back, I'm reminded that designing a programming language is not just about technical decisions, but also about understanding the diverse needs and backgrounds of its users. By acknowledging and embracing these differences, we can create a language that's both intuitive and powerful.